# Fairness Contract
This repository contains the source code, benchmark models, and datasets for the paper - "Design by Fairness Contract for Machine Learning Pipeline"

## Abstract
In the era of algorithmic decision-making, ensuring fairness while maintaining accuracy in machine learning (ML) systems is a critical challenge. To address this issue, new tools and methods are needed to detect and mitigate bias in ML-based software. While these approaches aim to fix fairness problems, they often fall short in preventing these issues in design time and informing users about them. Thus, we propose a preventive measure called a "Fairness Contract," which incorporates design-by-contract (DbC) principles for algorithmic fairness into the ML pipeline. Although Fairness Contract builds upon traditional DbC methods, we must address unique challenges. First, two types of fairness properties, hyperproperties and probabilistic properties, cannot be specified using conventional DbC mechanisms. Second, traditional DbC techniques do not support runtime assertion checking to report fairness violations in the ML pipeline. We address these issues by introducing a contract mechanism to capture fairness properties at different ML pipeline stages and report bias issues during runtime. These contracts abstract away the details of the ML algorithms, enabling systematic analysis and verification. In this work, we designed 24 contracts specifically targeting fairness bugs at various stages of the ML pipeline. These contracts were also used to evaluate our method on four fairness tasks, 45 buggy codes, and 24 correct codes. Our approach, Fairness Contract, is able to localize fairness bugs during runtime, which existing bug repair techniques cannot achieve. Moreover, Fairness Contract successfully identified 40 out of 45 buggy cases, outperforming existing fairness bug-fixing methods, which only managed to fix up to 35 out of 45 bugs. Fairness Contract also efficiently detects fairness bugs across various ML algorithms with a significantly shorter runtime. It only takes 1.5 seconds to detect and locate a bug, compared to the fastest existing method, which requires up to 30.9 seconds.
